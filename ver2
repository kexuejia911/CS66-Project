; Armen Mouradyan
; CS66 Project Milestone 1
; 12-03-2016

INCLUDE Irvine32.inc

BUFFER_SIZE = 9

;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
N = 3
T = N * N

Map struct

    num dword T DUP(0)
	par dword 0
	sib dword 0
	lev dword 0

Map ends

lastaddress = 44
paraddress = lastaddress - 8
presave = 362880
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.data?
	buffer BYTE BUFFER_SIZE DUP(?)
	fileHandle HANDLE ?

.data
	fileName BYTE "map.txt", 0

	newFlag BYTE 1
	winFlag BYTE 1

	menuTable BYTE 's'		;lookup value
			  DWORD NewGame		;address of procedure
	entrysize = ($ - MenuTable)
			  BYTE 'p'
			  DWORD PrintMap
			  BYTE 'u'
			  DWORD Up
			  BYTE 'd'
			  DWORD Down
			  BYTE 'l'
			  DWORD Left
			  BYTE 'r'
			  DWORD Right
			  BYTE 'e'
			  DWORD EndGame
			  BYTE 't'
			  DWORD Tree
	numberOfEntries = ($ - menuTable) / entrysize

	menu1 BYTE "s) Start a new game", 0
	menu2 BYTE "p) Print map", 0		;I think we should have map print in the menu anyway
	menu3 BYTE "u) Move zero up", 0
	menu4 BYTE "d) Move zero down", 0
	menu5 BYTE "l) Move zero left", 0
	menu6 BYTE "r) Move zero right", 0
	menu7 BYTE "e) End Game", 0
	menu8 BYTE "t) Print solution path", 0

	instructions BYTE "Complete the sliding puzzle by moving the zero around to line up the numbers in increasing order.", 0
	lineBreak BYTE "-----------------------------", 0
	winMessage BYTE "Congratulations! You got it!", 0

	;**********************************************************
	;The following 2-D arrays (solution and puzzleMap) 
	;are meant to be used as Based-Index-Displacement operands
	;in the form of displacement[base + index]
	;
	;Example:
	;mov eax, rowsizeSol ;row index
	;mov ebx, 2
	;mul ebx
	;mov ebx, eax
	;mov esi, 2		   ;column index
	;mov eax, TYPE solutionMap
	;mul esi
	;mov esi, eax
	;mov eax, solutionMap[ebx + esi] ;EAX = 3rd row, second column
	;**********************************************************

	solutionMap BYTE 1, 2, 3	;solution to puzzle
	rowsizeSol = ($ - solutionMap)
			 BYTE 4, 5, 6
			 BYTE 7, 8, 0
	 
	problemMap BYTE 4, 1, 6		;puzzle to be solved
	rowsizeProb = ($ - problemMap) 
			  BYTE 3, 5, 0
			  BYTE 7, 2, 8
	
;.data?
	puzzleMap BYTE 1, 2, 3		;in-progress puzzle
	rowsizePuz = ($ - puzzleMap) 
			  BYTE 4, 5, 6
			  BYTE 7, 0, 8


.code
	main PROC
		mov esi, OFFSET menuTable

		

COMMENT ^ ;old code that uses nested loops to check if winner. Not efficient.
		;***********************************
		;Nested loops to check if won
		;***********************************

		mov ecx, 3
	WOL:
		mov ebx, ecx
		push ecx

		mov ecx, 3

		WIL:
			push eax ;might not be needed
			push esi
			mov eax, rowsizePuz
			mov edx, 3
			sub edx, ebx
			mul edx
			mov esi, 3
			sub esi, ecx
			mov al, puzzleMap[eax + esi]
			.IF al != solutionMap[eax + esi]
				mov winFlag, 0
				jmp M1
			.ENDIF
			pop esi
			pop eax ;might not be needed
			loop WIL

		pop ecx
		loop WOL
		jmp M2

	M1:
		pop esi
		pop eax
		pop ecx
^

		;****************************
		;Play route
		;****************************

	M2:
		Call CheckWin
		.IF winFlag == 0 ;{
		L0:
			call Clrscr
			.IF newFlag == 1
				mov newFlag, 0
				call NewGame
			.ENDIF
				
			call PrintMap
			call PrintBreak
			call PrintMenu
			call ReadChar

			mov ecx, NumberOfEntries
			mov esi, OFFSET menuTable

		L1:
			cmp al, [esi]
			jne L2
			call NEAR PTR [esi + 1]
			jmp M2
		L2:
			add esi, entrysize
			loop L1
		;}

		;******************************
		;Win route
		;******************************

		.ELSEIF winFlag == 1 ;{
		L3: 
			call Clrscr
			call PrintMap

			call PrintBreak
			call PrintWinMessage
			call PrintBreak

			call PrintEndMenu
			call ReadChar

			.IF al == 's'
				call NewGame
			.ELSEIF al == 'p'
				call PrintMap
			.ELSEIF al == 'e'
				call EndGame
			.ELSE
				jmp L3
			.ENDIF

			jmp M2
		;}
		.ENDIF

		invoke ExitProcess,0
	main ENDP

	;---------------------------------------------
	;NewGame
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	NewGame PROC USES edx eax ecx ebx esi edi ;@TODO: list used registers
		;call Clrscr

		mov edx, OFFSET fileName
		call OpenInputFile
		mov fileHandle, eax
		
		mov edx, OFFSET buffer
		mov ecx, BUFFER_SIZE
		call ReadFromFile

		;mov edx, OFFSET buffer
		;call WriteString
		;call Crlf

		mov edi, 0
		mov ecx, 3 ;counter for OL

	OL:
		mov ebx, ecx
		push ecx

		mov ecx, 3 ;counter for IL

		IL:
			mov eax, rowsizePuz
			mov edx, 3
			sub edx, ebx
			mul edx
			mov edx, eax
			
			mov esi, 3
			sub esi, ecx

			mov eax, 0
			mov al, buffer[edi]
			sub al, 30
			sub al, 18
			mov puzzleMap[edx + esi], al
			

			inc edi
			loop IL

		pop ecx
		loop OL

		mov eax, fileHandle
		call CloseFile
		
		ret
	NewGame ENDP

	;---------------------------------------------
	;PrintMap
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	PrintMap PROC USES ecx eax ebx edx esi ;@TODO: list used registers
		call Clrscr
		mov ecx, 3

	OL:
		mov ebx, ecx
		push ecx

		mov ecx, 3

		IL:
			mov eax, rowsizePuz
			mov edx, 3
			sub edx, ebx
			mul edx
			mov edx, eax
			
			mov esi, 3
			sub esi, ecx

			mov eax, 0
			mov al, puzzleMap[edx + esi]
			call WriteDec
			mov al, TAB
			call WriteChar
			loop IL

			call crlf
			pop ecx
			loop OL

		call crlf
		ret
	PrintMap ENDP

	;---------------------------------------------
	;Up
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	Up PROC USES eax ebx esi ecx edx ;@TODO: list used registers
		mov ecx, 3
	Up1:
		mov esi, 3
		sub esi, ecx
		mov eax, rowsizePuz ;row index
		mov ebx, 1
		mul ebx
		mov ebx, eax
		mov eax, rowsizePuz ;row index
		mov edx, 2
		mul edx
		mov edx, eax
		mov eax, rowsizePuz ;row index

		.IF puzzleMap[ebx + esi] == 0 ;{ ;row 2, col n
			mov al, puzzleMap[ebx + esi] ;row 2, col n
			xchg al, puzzleMap[eax + esi] ;row 1, col  n
			mov puzzleMap[ebx + esi], al ;row 2, col n
			jmp Up2
		;}

		.ELSEIF puzzleMap[edx + esi] == 0 ;{ ;row 3, col n
			mov al, puzzleMap[edx + esi] ; row 3, col n
			xchg al, puzzleMap[ebx + esi] ;row 2, col  n
			mov puzzleMap[edx + esi], al ;row 3, col n
			jmp Up2
		;}
		.ENDIF
		loop Up1

	Up2:
		ret
	Up ENDP

	;---------------------------------------------
	;Down
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	Down PROC USES ebx esi ecx eax edx ;@TODO: list used registers
		mov ecx, 3
	Down1:
		mov ebx, rowsizePuz ;row index
		mov esi, 3
		sub esi, ecx
		mov esi, 3
		sub esi, ecx
		mov eax, rowsizePuz ;row index
		mov ebx, 1
		mul ebx
		mov ebx, eax
		mov eax, rowsizePuz ;row index
		mov edx, 2
		mul edx
		mov edx, eax
		mov eax, rowsizePuz ;row index

		.IF puzzleMap[esi] == 0 ;{ ;row 1, col n
			mov al, puzzleMap[esi] ; row 1, col n
			xchg al, puzzleMap[ebx + esi] ;row 2, col  n
			mov puzzleMap[esi], al ;row 1, col n
			jmp Down2
		;}

		.ELSEIF puzzleMap[ebx + esi] == 0 ;{ ;row 2, col n
			mov al, puzzleMap[ebx + esi] ;row 2, col n
			xchg al, puzzleMap[edx + esi] ;row 3, col  n
			mov puzzleMap[ebx + esi], al ;row 2, col n
			jmp Down2
		;}
		.ENDIF
		loop Down1

	Down2:
		ret
	Down ENDP

	;---------------------------------------------
	;Left
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	Left PROC USES eax ebx ecx ;@TODO: list used registers
		mov ecx, 3
	Left1:
		mov eax, rowsizePuz ;row index
		mov ebx, 3
		sub ebx, ecx
		mul ebx

		.IF puzzleMap[eax + 1] == 0 ;{ ;row n, col 2
			mov bl, puzzleMap[eax + 1] ; row n, col 2
			xchg bl, puzzleMap[eax] ;row n, col  1
			mov puzzleMap[eax + 1], bl ;row n, col 2
			jmp Left2
		;}

		.ELSEIF puzzleMap[eax + 2] == 0 ;{ ;row n, col 3
			mov bl, puzzleMap[eax + 2] ;row n, col 3
			xchg bl, puzzleMap[eax + 1] ;row n, col  2
			mov puzzleMap[eax + 2], bl ;row n, col 3
			jmp Left2
		;}
		.ENDIF
		loop Left1

	Left2:
		ret
	Left ENDP

	;---------------------------------------------
	;Right
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	Right PROC USES ebx ecx eax ;@TODO: list used registers
		mov ecx, 3
	Right1:
		mov eax, rowsizePuz ;row index
		mov ebx, 3
		sub ebx, ecx
		mul ebx

		.IF puzzleMap[eax] == 0 ;{ ;row n, col 1
			mov bl, puzzleMap[eax] ; row n, col 1
			xchg bl, puzzleMap[eax + 1] ;row n, col  2
			mov puzzleMap[eax], bl ;row n, col 1
			jmp Right2
		;}

		.ELSEIF puzzleMap[eax + 1] == 0 ;{ ;row n, col 2
			mov bl, puzzleMap[eax + 1] ;row n, col 2
			xchg bl, puzzleMap[eax + 2] ;row n, col  3
			mov puzzleMap[eax + 1], bl ;row n, col 2
			jmp Right2
		;}
		.ENDIF
		loop Right1

	Right2:
		ret
	Right ENDP

	;---------------------------------------------
	;EndGame
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	EndGame PROC USES edx ;@TODO: list used registers
		invoke ExitProcess,0
		ret
	EndGame ENDP

	;---------------------------------------------
	;PrintMenu
	;
	;Prints the full menu {s,...,e}
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	PrintMenu PROC USES edx ;@TODO: list used registers
		mov edx, OFFSET menu1
		call WriteString
		call Crlf
		
		mov edx, OFFSET menu2
		call WriteString
		call Crlf

		mov edx, OFFSET menu3
		call WriteString
		call Crlf

		mov edx, OFFSET menu4
		call WriteString
		call Crlf

		mov edx, OFFSET menu5
		call WriteString
		call Crlf

		mov edx, OFFSET menu6
		call WriteString
		call Crlf

		mov edx, OFFSET menu7
		call WriteString
		call Crlf

		mov edx, OFFSET menu8
		call WriteString
		call Crlf

		ret
	PrintMenu ENDP

	;---------------------------------------------
	;PrintEndMenu
	;
	;Prints menu after completed game {s, p, e}
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	PrintEndMenu PROC USES edx ;@TODO: list used registers
		mov edx, OFFSET menu1
		call WriteString
		call Crlf

		mov edx, OFFSET menu2
		call WriteString
		call Crlf

		mov edx, OFFSET menu7
		call WriteString
		call Crlf

		ret
	PrintEndMenu ENDP

	;---------------------------------------------
	;PrintBreak
	;
	;@TODO: Description, Recieve and return list
	;----------------------------------------------

	PrintBreak PROC USES edx ;@TODO: list used registers
		mov  edx, OFFSET lineBreak
		call WriteString
		call Crlf
		ret
	PrintBreak ENDP

	;---------------------------------------------
	;PrintWinMessage
	;
	;
	;@TODO: Description, Recieve and return list
	; 
	;----------------------------------------------

	PrintWinMessage PROC USES edx ;@TODO: list used registers
		mov edx, OFFSET winMessage
		call WriteString
		call Crlf
		ret
	PrintWinMessage ENDP

	;---------------------------------------------
	;CheckWin
	;
	;
	;@TODO: Description, Recieve and return list
	; Recieves: N/A
	;----------------------------------------------

	CheckWin PROC USES edx ecx eax ebx esi ;@TODO: list used registers

		mov esi, OFFSET puzzleMap
		mov eax, LENGTHOF puzzleMap
		mov ecx, rowsizePuz
		mul ecx
		dec eax
		mov ecx, eax ;for our counter. Should be n - 1 in an n x n array.
		mov edx, 0
	
	WL:
		mov ebx, 0
		mov bl, [esi]
		inc edx
		.IF ebx != edx
			mov winFlag, 0
			ret
		.ELSE
			inc esi
			loop WL
		.ENDIF
		mov winFlag, 1
		ret
	CheckWin ENDP

	;---------------------------------------------
	;Tree
	;
	;
	;@TODO: Description, Recieve and return list
	; Recieves: N/A
	;----------------------------------------------

	Tree PROC USES esi ;@TODO: list used registers
		mov esi, OFFSET PuzzleMap

		call Crlf
		call PrintBreak
		call Crlf

		Call Begin
		Call SPrint

		Call Crlf
		Call PrintBreak
		Call Crlf
		Call WaitMsg

		ret
	Tree ENDP

	;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.data
hHeap dword 0
curM dword 0
lastM dword 0
nextM dword 0
arr dword T DUP(0)
cheatlist dword presave DUP(0)
list dword presave DUP(0)

set0 dword HEAP_ZERO_MEMORY
sizel dword type Map
solution dword 1,2,3,4,5,6,7,8,0
checkmark dword 0
count dword 0
level dword 0
number dword 0

thisM Map <>

.code
Free proc

    mov esi,0
	mov eax,cheatlist[esi]
	ret
	Free endp

NonGen proc uses ecx eax esi

    mov ecx,T
	mov edi,0
	L1:
	movzx eax,byte ptr [esi]
	mov thisM.num[edi],eax
	inc esi
	add edi,4
	loop L1

	mov thisM.par,0
	mov thisM.sib,0
	mov thisM.lev,0

	ret
NonGen endp

Findout proc

    mov esi,0
	mov edi,0
    mov ecx,count    
L1:
	add esi,4
	loop L1
	sub esi,4
	mov ebx,cheatlist[esi]
	mov list[edi],ebx
	add edi,4
	inc number
L2:
    .if ebx != 0
	mov eax,[ebx+paraddress]
	.if eax != 0
	mov list[edi],eax
	inc number
	add edi,4
	.endif
	mov ebx,eax
	jmp L2
	.endif

	ret
Findout endp

SPrint proc uses eax ebx ecx edx esi edi

    call Findout
    mov edi,0
	mov ecx,number
L0:
	add edi,4
	loop L0
	sub edi,4
	mov ecx,number
L1:
	mov esi,list[edi]
	call ToArr
	push ecx
	mov ecx,N
	mov ebx,0
L2:
	push ecx
	mov ecx,N
L3:
	mov eax,arr[ebx]
	add ebx,4
	call WriteDec
	loop L3

	call crlf
	pop ecx
	loop L2

	pop ecx
	sub edi,4
	call crlf
	loop L1

    ret
	Sprint endp

Begin proc uses eax ebx ecx edx esi edi

    call NonGen
	mov count,0
	mov number,0
	mov level,0

    INVOKE GetProcessHeap
	mov hHeap,eax
	
	mov edi,0
	call Creat
	mov esi,ebx
	mov cheatlist[edi],esi
	add edi,4
	call ToHeap
	add count,1
    call Move

	ret
Begin endp

Creat proc uses eax

    INVOKE heapAlloc,hHeap,set0,sizel
	mov ebx,eax
    ret

Creat endp

;esi is the address of heap to allocate
ToHeap proc uses eax ecx esi edi

    mov edi,0
	mov ecx,T

L1:
    mov eax,thisM.num[edi]
	mov [esi],eax
	add esi,4
	add edi,4
	loop L1

	mov eax,thisM.par
	mov [esi],eax
	add esi,4
	mov eax,thisM.sib
	mov [esi],eax
	add esi,4
	mov eax,thisM.lev
	mov [esi],eax

	ret
ToHeap endp

;esi is the address of heap to take out
ToMap proc uses eax ecx esi edi
    
    mov edi,0
	mov ecx,T

L1:
    mov eax,[esi]
	mov thisM.num[edi],eax
	add esi,4
	add edi,4
	loop L1

	mov eax,[esi]
	mov thisM.par,eax
	add esi,4
	mov eax,[esi]
	mov thisM.sib,eax
	add esi,4
	mov eax,[esi]
	mov thisM.lev,eax

	ret
ToMap endp

SaveP proc uses eax
    
	mov eax,curM
	mov thisM.par,eax

	ret
SaveP endp

SaveS proc uses eax
    
	mov eax,nextM
	mov thisM.sib,eax

	ret
SaveS endp

SaveL proc uses eax
    
	mov eax,level
	mov thisM.sib,eax

	ret
SaveL endp

;return eax
Find proc uses ebx ecx edi

    call ToMap
    mov eax,0
	mov edi,0
	mov ecx,T
L1:
    mov ebx,thisM.num[edi]
    .if ebx == 0
	jmp L2
	.endif
	inc eax
	add edi,4
	loop L1

L2:
    ret
Find endp

ToArr proc uses eax ecx esi edi
    
	mov edi,0
	mov ecx,T
L1:
	mov eax,[esi]
	mov arr[edi],eax
	add esi,4
	add edi,4
	loop L1

	ret
ToArr endp


;return edx
Compare proc uses eax ebx ecx esi

   mov esi,0
   mov edx,0
   mov ecx,T

L1:
   mov eax,thisM.num[esi]
   mov ebx,arr[esi]
   .if eax == ebx
   inc edx
   .endif
   add esi,4
   loop L1

   .if edx == T
   jmp L2
   .endif

   mov checkmark,0
   ret

L2:
   mov checkmark,1
   ret

Compare endp

Fin proc uses eax ecx ebx esi

   mov esi,0
   mov edx,0
   mov ecx,T

L1:
   mov eax,thisM.num[esi]
   mov ebx,solution[esi]
   .if eax == ebx
   inc edx
   .endif
   add esi,4
   loop L1

   cmp edx,T
   jl L2

   mov checkmark,2
   ret

L2:
   mov checkmark,0
   ret

Fin endp

Search proc uses esi ecx edi esi

    .if checkmark == 2
	jmp L2
	.endif
    
	call Fin
	.if checkmark == 2
	jmp L2
	.endif
	mov edi,0
	mov ecx,count

L1:
    mov esi,cheatlist[edi]
    call ToArr
    call Compare
	.if checkmark == 1
	jmp L2
	.endif
	add edi,4
	loop L1

L2:
    ret

Search endp


UpS proc uses ebx

    mov ebx,thisM.num[eax*4]
	sub eax,N
	mov edx,thisM.num[eax*4]
	mov thisM.num[eax*4],ebx
	add eax,N
	mov thisM.num[eax*4],edx

	call Search
	ret
UpS endp


DownS proc uses ebx

    mov ebx,thisM.num[eax*4]
	add eax,N
	mov edx,thisM.num[eax*4]
	mov thisM.num[eax*4],ebx
	sub eax,N
	mov thisM.num[eax*4],edx

	call Search
	ret
DownS endp

LeftS proc uses ebx

    mov ebx,thisM.num[eax*4]
	dec eax
	mov edx,thisM.num[eax*4]
	mov thisM.num[eax*4],ebx
	inc eax
	mov thisM.num[eax*4],edx

	call Search
	ret
LeftS endp

RightS proc uses ebx

    mov ebx,thisM.num[eax*4]
	inc eax
	mov edx,thisM.num[eax*4]
	mov thisM.num[eax*4],ebx
	dec eax
	mov thisM.num[eax*4],edx

	call Search
	ret
RightS endp

New proc

    call Creat
	mov esi,ebx
	mov cheatlist[edi],ebx
	add edi,4
	mov ecx,lastM
	mov nextM,ecx
	mov lastM,ebx
	call SaveP
	call SaveS
	call SaveL
	call ToHeap
	add count,1

	ret
New endp

MoveU proc uses eax ebx ecx

    mov esi,curM
	call ToMap
	call UpS
	.if checkmark == 0
	call New
	.endif
	.if checkmark == 2
	call New
	.endif

	ret
MoveU endp

MoveD proc uses eax ebx ecx

    mov esi,curM
	call ToMap
	call DownS
	.if checkmark == 0
	call New
	.endif
	.if checkmark == 2
	call New
	.endif

	ret
MoveD endp

MoveL proc uses eax ebx ecx

    mov esi,curM
	call ToMap
	call LeftS
	.if checkmark == 0
	call New
	.endif
	.if checkmark == 2
	.endif

	ret
MoveL endp

MoveR proc uses eax ebx ecx

    mov esi,curM
	call ToMap
	call RightS
	.if checkmark == 0
	call New
	.endif
	.if checkmark == 2
	call New
	.endif

	ret
MoveR endp

Cont proc uses eax ecx ebx edx

    .if checkmark == 0
	call Move
	.endif

	ret
Cont endp

Save proc
   
	mov ecx,curM
	mov ebx,lastM
	mov edx,nextM
    
	ret
Save endp

Load proc
    
	mov curM,ecx
	mov lastM,ebx
	mov nextM,edx
    
	ret
Load endp

GoU proc

    .if checkmark == 2
	ret
	.endif
    
	call MoveU
	call Save
	call Cont
	call Load

	ret
GoU endp

GoD proc

    .if checkmark == 2
	ret
	.endif
    
	call MoveD
	call Save
	call Cont
	call Load

	ret
GoD endp

GoL proc

    .if checkmark == 2
	ret
	.endif
    
	call MoveL
	call Save
	call Cont
	call Load

	ret
GoL endp

GoR proc

    .if checkmark == 2
	ret
	.endif
    
	call MoveR
	call Save
	call Cont
	call Load

	ret
GoR endp
   
;To use N value, the only thing we need change is function below

P0 proc uses eax ecx

    inc level
    mov curM,esi
	mov lastM,0

	call GoD
	call GoR

	dec level

	ret
P0 endp

P1 proc uses eax ecx

    inc level
    mov curM,esi
	mov lastM,0

	call GoD
	call GoL
	call GoR

	dec level

	ret

P1 endp

P2 proc uses eax ecx

    inc level
    mov curM,esi
	mov lastM,0

	call GoD
	call GoL

	dec level

	ret
P2 endp

P3 proc uses eax ecx 

    inc level
    mov curM,esi
	mov lastM,0

	call GoU
	call GoR
	call GoD

	dec level

	ret
P3 endp

P4 proc uses eax ecx 

    inc level
    mov curM,esi
	mov lastM,0

	call GoU
	call GoL
	call GoR
	call GoD

	dec level

	ret
P4 endp

P5 proc uses eax ecx 

    inc level
    mov curM,esi
	mov lastM,0

	call GoU
	call GoL
	call GoD

	dec level

	ret
P5 endp

P6 proc uses eax ecx 

    inc level
    mov curM,esi
	mov lastM,0

	call GoU
	call GoR

	dec level

	ret
P6 endp

P7 proc uses eax ecx 

    inc level
    mov curM,esi
	mov lastM,0

	call GoR
	call GoL
	call GoU

	dec level

	ret
P7 endp

P8 proc uses eax ecx 

    inc level
    mov curM,esi
	mov lastM,0

	call GoU
	call GoL

	dec level

	ret
P8 endp

Move proc uses eax ecx

    .if checkmark == 2
	ret
	.endif

    call Find

	.if eax == 0
	call P0
	.endif
	.if eax == 1
	call P1
	.endif
	.if eax == 2
	call P2
	.endif
	.if eax == 3
	call P3
	.endif
	.if eax == 4
	call P4
	.endif
	.if eax == 5
	call P5
	.endif
	.if eax == 6
	call P6
	.endif
	.if eax == 7
	call P7
	.endif
	.if eax == 8
	call P8
	.endif

	ret
Move endp

	END main
